---
title: 数组
date: 2018-10-13 10:25:11
tags: 数组
categories: 数据结构和算法
---

#### 数组的随机访问

数组是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组具有**相同类型**的数据。



线性表：线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。



连续的内存空间和相同类型的数据使得数组拥有“随机访问”的特性，但也让数组的很多操作变得低效，比如插入和删除一个数据，为了保证连续性需要做大量的数据搬移工作。



计算机通过寻址公式计算出元素存储的内存地址来随机访问数组中的某个元素：

```
a[i]_address = base_address + i * data_type_size
```



数组和链表的区别：数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。



##### 低效的“插入”和“删除”

先看插入操作。



对于插入操作的时间复杂度，如果在末尾插入则复杂度为 O(1)，如果在中间插入则复杂度为 O(n)。平均复杂度为（1+2+...n）/n=O(n)。



改进方法：当数组中存储的数据没有任何规律，只被当作一个存储数据的集合时，在第  k  个位置插入数据，为了避免数据的大规模迁移，可以直接将第 k 位的数据搬移到数组的末尾，把新元素直接放在第 k 个位置。利用这种技巧可以将复杂度降为 O(1)。这个思想在**快排**中也会用到。



再看删除操作。



时间复杂度和插入一样。



改进方法：当某些情景下，我们不追求数组中数据的连续性。可以将多次删除操作集中在一起执行来提高效率。



来看个例子。数组 a[10] 中存储了8个元素，我们依次删除 前三个元素。为避免多次搬移后面的数据，我们可以先记录下已经删除的数据。每次的删除操作并不真正的搬移数据，只是记录数据已经被删除。当数据没有更多空间存储数据时，再触发执行一次真正的删除操作，这样大大减少了删除操作导致的数据搬移。这其实就是 JVM 标记清除垃圾回收算法的核心思想。



##### 警惕数组访问越界

在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。数组越界是一种未决行为，并没规定编译器应如何处理。Debug 难度非常大，一定要警惕数组越界。



#### 容器与数组

容器的优势：封装了许多操作细节、支持动态扩容。

需要注意的是容器扩容涉及内存申请和数据搬移，比较耗时。如果能事先确定数据大小，最好在创建容器时指定数据大小。



对于业务开发，直接使用容器省时省力。如果是底层开发，比如网络框架，性能的优化需要做到极致，这是数组是首选。